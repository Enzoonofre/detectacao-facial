# -*- coding: utf-8 -*-
"""Reconhecimento_facil.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Td57wTqdsXhq3vCpSVrjdX6SXuWxvBog
"""

!pip install deepface

import cv2
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt

# Carregar o classificador de rostos
classificador = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

# Carregar a imagem
imagem = cv2.imread("pessoas.jpg")
imagem_cinza = cv2.cvtColor(imagem, cv2.COLOR_BGR2GRAY)

# Detectar rostos
rostos = classificador.detectMultiScale(imagem_cinza, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

# Desenhar retângulos ao redor dos rostos
for (x, y, w, h) in rostos:
    cv2.rectangle(imagem, (x, y), (x+w, y+h), (255, 0, 0), 2)

# Exibir a imagem com os rostos destacados
plt.imshow(cv2.cvtColor(imagem, cv2.COLOR_BGR2RGB))
plt.show()

from google.colab import drive
drive.mount('/content/drive')

!ls /content/drive/MyDrive/

!cp -r "/content/drive/MyDrive/dataset-rostos" /content/

import os
from PIL import Image

# Função para limpar imagens quebradas e limitar a quantidade de imagens por categoria
def clean_and_limit_images(data_dir, categories, limit):
    for category in categories:
        category_path = os.path.join(data_dir, category)
        images = os.listdir(category_path)
        valid_images = []

        for img_name in images:
            img_path = os.path.join(category_path, img_name)
            try:
                img = Image.open(img_path)
                img.verify()  # Verifica se a imagem está quebrada
                valid_images.append(img_name)
            except (IOError, SyntaxError):
                os.remove(img_path)  # Remove a imagem quebrada

        # Limita a quantidade de imagens por categoria
        for img_name in valid_images[limit:]:
            os.remove(os.path.join(category_path, img_name))

# URL do dataset e caminhos dos arquivos
data_dir = "/content/dataset-rostos"
categories = ["Enzo", "leonard","raj","sheldon","unknown","howard"]
limit = 30




# Limpar imagens quebradas e limitar a quantidade de imagens por categoria
print("Limpando imagens quebradas e limitando a quantidade de imagens por categoria")
clean_and_limit_images(data_dir, categories, limit)

# Verificar o conteúdo extraído
print("Conteúdo extraído:")
for category in categories:
    print(f"{category}: {len(os.listdir(os.path.join(data_dir, category)))} imagens")

import os
import numpy as np
from deepface import DeepFace
import pickle

# Diretório do dataset
data_dir = "/content/dataset-rostos"

# Dicionário para armazenar embeddings
embeddings = []
labels = []

# Percorrer cada pasta (classe)
for class_name in os.listdir(data_dir):
    class_path = os.path.join(data_dir, class_name)
    if not os.path.isdir(class_path):
        continue

    for img_name in os.listdir(class_path):
        img_path = os.path.join(class_path, img_name)

        try:
            # Gerar embedding com DeepFace
            embedding = DeepFace.represent(img_path, model_name="Facenet")[0]['embedding']
            embeddings.append(embedding)
            labels.append(class_name)
        except:
            print(f"Erro ao processar {img_path}")

# Converter para NumPy
X = np.array(embeddings)
y = np.array(labels)

# Salvar os embeddings para uso futuro
with open("embeddings.pkl", "wb") as f:
    pickle.dump((X, y), f)

print("✅ Embeddings extraídos e salvos!")

from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
import pickle

# Carregar embeddings
with open("embeddings.pkl", "rb") as f:
    X, y = pickle.load(f)

# Dividir em treino e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=42)

# Treinar um classificador SVM
clf = SVC(kernel="linear", probability=True)
clf.fit(X_train, y_train)

# Salvar modelo treinado
with open("modelo_svm.pkl", "wb") as f:
    pickle.dump(clf, f)

print("✅ Modelo treinado e salvo!")

import cv2
import numpy as np
import matplotlib.pyplot as plt
import pickle
from deepface import DeepFace

# Carregar modelo treinado
with open("modelo_svm.pkl", "rb") as f:
    clf = pickle.load(f)

# Função para processar a imagem
def processar_imagem(img_name):
    # Caminho da imagem de teste
    img_path = f"/content/{img_name}"

    # Carregar imagem
    img = cv2.imread(img_path)

    # Verificar se a imagem foi carregada corretamente
    if img is None:
        raise FileNotFoundError(f"Erro: Não foi possível carregar a imagem em {img_path}. Verifique o caminho.")

    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)  # Converter para RGB

    # Detectar rostos na imagem
    face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")
    faces = face_cascade.detectMultiScale(img, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

    if len(faces) == 0:
        print("Nenhum rosto detectado.")
    else:
        plt.figure(figsize=(10, 6))

        for (x, y, w, h) in faces:
            face_crop = img[y:y+h, x:x+w]  # Recortar rosto

            try:
                # Extrair embedding do rosto
                embedding = DeepFace.represent(face_crop, model_name="Facenet")[0]['embedding']

                # Fazer previsão com SVM
                predicao = clf.predict([embedding])[0]
                probabilidades = clf.predict_proba([embedding])[0]
                confianca = max(probabilidades) * 100  # Confiança da previsão

                # Desenhar retângulo no rosto
                cv2.rectangle(img_rgb, (x, y), (x + w, y + h), (255, 0, 0), 3)

                # Adicionar rótulo com o nome e a confiança
                label = f"{predicao} ({confianca:.2f}%)"
                cv2.putText(img_rgb, label, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 0, 0), 2, cv2.LINE_AA)

            except Exception as e:
                print(f"Erro ao processar rosto: {e}")

        # Exibir imagem com os rótulos
        plt.imshow(img_rgb)
        plt.axis("off")
        plt.show()

# Exemplo de uso da função
processar_imagem("pessoas.jpg")

processar_imagem("ft.jpeg")